# Future Enhancement: Process Pool per Working Directory

**Status**: Future / Research Required
**Priority**: Low (current `--resume` approach is sufficient)
**Blocked By**: Claude Code CLI architecture limitations

---

## 1. Motivation

### 1.1 Current Behavior

Currently, each prompt to Claude Code spawns a new process:

```
Prompt Request -> spawn("claude", ["-p", prompt]) -> Process runs -> Process exits
```

This means:
- Process startup overhead for every prompt (~500ms-1s)
- No process reuse across prompts
- Resources allocated and deallocated repeatedly

### 1.2 Desired Behavior

A process pool mechanism would:
- Pre-create `default_n` processes per working directory on first request
- Reuse processes by executing `/clear` to reset context after each prompt
- Extend pool by `extend_n` processes when exhausted
- Reduce latency for high-frequency prompt scenarios
- Provide predictable capacity management

### 1.3 Use Cases

| Use Case | Benefit |
|----------|---------|
| High-frequency prompt execution | Reduced latency |
| Multi-tenant daemon serving multiple clients | Resource isolation per project |
| Batch processing workflows | Predictable throughput |
| Interactive TUI with rapid prompt iteration | Responsive user experience |

---

## 2. Proposed Architecture

### 2.1 Pool Structure

```
ProcessPoolManager
  |
  +-- WorkingDirectoryPool (projectPath: "/path/to/project-a")
  |     +-- Worker[0]: { process, status: "idle" | "busy", lastUsed }
  |     +-- Worker[1]: { process, status: "idle" | "busy", lastUsed }
  |     +-- Worker[2]: { process, status: "idle" | "busy", lastUsed }
  |
  +-- WorkingDirectoryPool (projectPath: "/path/to/project-b")
        +-- Worker[0]: { process, status: "idle", lastUsed }
        +-- Worker[1]: { process, status: "busy", lastUsed }
```

### 2.2 Pool Configuration

```typescript
interface ProcessPoolConfig {
  /** Initial number of processes per working directory */
  defaultN: number;  // e.g., 2

  /** Number of processes to add when pool is exhausted */
  extendN: number;   // e.g., 1

  /** Maximum processes per working directory */
  maxN: number;      // e.g., 5

  /** Idle timeout before process is terminated (ms) */
  idleTimeoutMs: number;  // e.g., 300000 (5 minutes)

  /** Health check interval (ms) */
  healthCheckIntervalMs: number;  // e.g., 30000
}
```

### 2.3 Lifecycle

```
1. First Request for /project-a
   -> Create WorkingDirectoryPool with default_n workers
   -> Acquire worker[0], mark as "busy"
   -> Send prompt
   -> On completion: execute /clear, mark as "idle", return to pool

2. Subsequent Request for /project-a
   -> Find idle worker in pool
   -> If found: acquire, send prompt
   -> If not found: extend pool by extend_n (up to max_n)
   -> If at max_n: wait for available worker

3. Remove Pool for /project-a
   -> Send SIGTERM to all workers
   -> Wait for graceful shutdown
   -> Remove pool from manager
```

---

## 3. Technical Challenges

### 3.1 Critical: Claude Code CLI Mode

**Problem**: Claude Code's `-p` (programmatic) mode is designed for single-prompt invocation.

```bash
# Current: Process exits after completing prompt
claude -p "analyze code" --output-format stream-json
# Process exits immediately after response
```

**Required**: Long-lived interactive mode that:
- Stays alive waiting for input
- Accepts prompts via stdin
- Accepts `/clear` command via stdin
- Continues outputting structured JSON

**Status**: Not currently supported by Claude Code CLI.

### 3.2 Critical: Prompt Delivery After /clear

**Problem**: How to send subsequent prompts to a pooled process?

| Approach | Feasibility | Issues |
|----------|-------------|--------|
| **stdin pipe** | Requires CLI support | Cannot send multi-turn conversations (user/assistant history) |
| **Custom session file** | Requires CLI support | Session ID is generated by Claude Code, not externally specifiable |
| **Named pipe / Unix socket** | Requires CLI changes | Would need Claude Code to listen on IPC |
| **HTTP endpoint** | Requires Claude Code server mode | Not available |

**Status**: No viable approach without Claude Code CLI changes.

### 3.3 Session ID Management

**Problem**: Session ID is returned by Claude Code in output, not specifiable as input.

```bash
# Current: Session ID is OUTPUT
output=$(claude -p "start" --output-format json)
session_id=$(echo "$output" | jq -r '.session_id')

# Cannot do: Session ID as INPUT
claude --session-id "my-custom-id" -p "continue"  # NOT SUPPORTED
```

**Impact**: Cannot pre-create sessions for pooled processes.

### 3.4 Context State After /clear

**Questions requiring verification**:
- Does `/clear` fully reset all context (conversation history, tool state, MCP connections)?
- Does `/clear` preserve authentication state?
- Does `/clear` reset `CLAUDE.md` parsing or keep it cached?
- What is the output format when `/clear` is executed?

### 3.5 Process Health Monitoring

**Challenges**:
- How to detect if a pooled process has become unresponsive?
- How to handle processes that crash or exit unexpectedly?
- How to verify process is truly "idle" and ready for next prompt?

---

## 4. Issues to Resolve

### 4.1 Before Implementation Can Begin

| Issue | Owner | Status |
|-------|-------|--------|
| Claude Code CLI interactive mode support | Anthropic | Unknown |
| stdin-based prompt delivery | Anthropic | Not supported |
| External session ID specification | Anthropic | Not supported |
| /clear command behavior documentation | Anthropic | Limited |

### 4.2 Design Decisions Needed

| Decision | Options | Recommendation |
|----------|---------|----------------|
| Pool granularity | Per working directory vs. global | Per working directory (isolation) |
| Worker selection strategy | FIFO, LRU, random | LRU (most recently cleared) |
| Extension trigger | On exhaustion vs. predictive | On exhaustion (simpler) |
| Idle worker cleanup | Time-based vs. memory pressure | Time-based with configurable timeout |
| Error handling | Kill and replace vs. retry | Kill and replace (clean state) |

### 4.3 Implementation Dependencies

```
1. Claude Code CLI changes (external dependency)
   |
   v
2. ProcessManager interface extension (keep stdin open)
   |
   v
3. ProcessPoolManager implementation
   |
   v
4. Integration with QueueRunner and GroupRunner
   |
   v
5. Pool management API for daemon
```

---

## 5. Alternative Approaches

### 5.1 Current Approach: --resume (Recommended for Now)

```bash
# First prompt
session_id=$(claude -p "analyze" --output-format json | jq -r '.session_id')

# Subsequent prompts (new process, same session context)
claude -p "continue analysis" --resume "$session_id"
```

**Pros**:
- Works with current Claude Code CLI
- Session context is preserved
- Simple implementation

**Cons**:
- Process startup overhead per prompt
- No process reuse

### 5.2 Daemon Mode with Connection Pooling

If Claude Code adds a daemon/server mode:
```bash
# Start daemon
claude daemon --port 8080

# Send prompts via HTTP
curl -X POST http://localhost:8080/prompt -d '{"prompt": "analyze"}'
```

**Status**: Not available.

### 5.3 Wrapper Process

Create a wrapper that:
1. Starts Claude Code in interactive mode (if available)
2. Accepts prompts via IPC
3. Translates to Claude Code input format

**Complexity**: High, fragile, depends on undocumented behavior.

---

## 6. Recommendations

### 6.1 Short Term (Current)

**Continue using `--resume` approach**. It provides session context continuity with acceptable performance for most use cases.

### 6.2 Medium Term

**Monitor Claude Code CLI updates** for:
- Interactive mode support
- stdin-based prompt input
- Server/daemon mode
- External session ID specification

### 6.3 Long Term

**If Claude Code adds required features**, implement process pool with:
1. Start with simple pool (default_n=1, extend_n=1)
2. Add health monitoring
3. Add idle cleanup
4. Add metrics/observability

---

## 7. Related References

- `src/sdk/queue/runner.ts:584-599` - TODO comment with enhancement summary
- `src/sdk/group/runner.ts:512-514` - Cross-reference to queue runner
- `design-docs/reference-claude-code-internals.md` - Claude Code CLI options
- `design-docs/spec-command-queue.md` - Current session mode implementation

---

## 8. Open Questions

1. **Q**: Will Anthropic add an interactive/daemon mode to Claude Code CLI?
   **A**: Unknown. No public roadmap available.

2. **Q**: Is the startup overhead (~500ms-1s) significant enough to warrant this complexity?
   **A**: Depends on use case. For batch processing: yes. For occasional prompts: no.

3. **Q**: Could we achieve similar benefits with process pre-warming (spawn but don't execute)?
   **A**: Potentially, but still requires new process per prompt. Limited benefit.

4. **Q**: Are there memory/resource concerns with keeping idle processes?
   **A**: Yes. Each Claude Code process uses ~100-300MB. Pool of 5 = 500MB-1.5GB per working directory.
